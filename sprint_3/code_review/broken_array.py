import sys


"""
-- ID ПОСЫЛКИ - 51757796 --

-- ПРИНЦИП РАБОТЫ --
Массив все еще остается частично отсортирован: правая или левая сторона упорядочена.
Используем стратегию разделяй и властвуй - разбиваем на каждоый итерации массив пополам.
Получаем индекс середины массива. Если искомый элемент находится по этому индеку - возвращаем его.
Если элемент с индексом левой границы массива меньше, чем элемент с индексом середины, то мы понимаем, что левая половина отсортирована.
Если элемент с индексом левой массива больше, чем элемент с индексом середины, то отсортирована правая половина. 
Проверяем входит ли искомый элемент в отсортированную половину массива, сравнивая с его граничными элементами. 
Если входит то рекурсивно запускаем функцию, передавая в нее новые грацицы. 
Если нет - то значит элемент в неотсортированной части массива, продолж рекурсивно поиск в ней.
По условию задачи в массиве могут быть только уникальные элементы. 
Но я это пропустил и написал решение для массивов с возможными неуникальными элементами :)
До этого мы сравнивали больше или меньше элемент с индексом левой границы чем элемент с индексом середины. 
Если окажется, что эти элементы равны - значит в левой половине есть дубли.
В таком случае, мы сначала сравниваем середину с правой стороной массива. Если они не равны, то ищем там.
Если равны, то ищем и в левой половине и в правой поочереди.    

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
В случае с уникальностью всех элементов массива мы получаем такую же сложность как в бинарном поиске - O(log n).
Если же в массиве будут дубли, то сложность алгоритма может деградировать до O(n), 
так как придется часто проверять обе части массива в одной итерации.

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Алгоритм резервирует дополнительную память на указатели границ и середины массива
на каждом уровне рекурсии. Так как глубина рекурсии в среднем случае составит O(log n),
а в худшем O(n), то и дополнительной памяти потребуется столько же. 
"""


def search(needle, numbers):
    return broken_search(numbers, needle, 0, len(numbers) - 1)


def broken_search(numbers, needle, left, right):
    mid = (left + right) // 2

    if needle == numbers[mid]:
        return mid

    if right < left:
        return -1

    if numbers[left] < numbers[mid]:
        if numbers[left] <= needle < numbers[mid]:
            return broken_search(numbers, needle, left, mid - 1)
        else:
            return broken_search(numbers, needle, mid + 1, right)
    elif numbers[left] > numbers[mid]:
        if numbers[mid] < needle <= numbers[right]:
            return broken_search(numbers, needle, mid + 1, right)
        else:
            return broken_search(numbers, needle, left, mid - 1)
    else:
        if numbers[mid] != numbers[right]:
            return broken_search(numbers, needle, mid + 1, right)
        else:
            result = broken_search(numbers, needle, left, mid - 1)

            if result == -1:
                return broken_search(numbers, needle, mid + 1, right)
            else:
                return result


def main():
    sys.stdin.readline()
    needle = int(sys.stdin.readline().strip())
    numbers = sys.stdin.readline().strip().split(' ')
    numbers = [int(i) for i in numbers]
    print(search(needle, numbers))


if __name__ == '__main__':
    main()
